[include mainsail.cfg]

[mcu]
serial: /dev/serial/by-id/<your-mcu-id>

[virtual_sdcard]
path: /home/borealis/printer_data/gcodes
on_error_gcode: CANCEL_PRINT


## config/kinematics/corexy.cfg
[printer]
kinematics: corexy
max_velocity: 400
max_accel: 8000
max_z_velocity: 30
max_z_accel: 500
# minimum_cruise_ratio: 0.5 # This left commented to not break older Klipper versions
square_corner_velocity: 5.0


## config/machine.cfg
[virtual_sdcard]
path: ~/printer_data/gcodes
on_error_gcode:
    {% if printer["gcode_macro _USER_VARIABLES"].status_leds_enabled %}
        STATUS_LEDS COLOR="ERROR"
    {% endif %}
    {% if printer["gcode_macro _USER_VARIABLES"].probe_type_enabled == "dockable" or printer["gcode_macro _USER_VARIABLES"].probe_type_enabled == "dockable_virtual" %}
        _PROBE_ON_ERROR_ACTION
    {% endif %}

    # Park only if printer is homed
    {% if "xyz" in printer.toolhead.homed_axes %}
        PARK
    {% endif %}
    
[idle_timeout]
timeout: 1800
gcode:
    RESPOND MSG="Idle timeout reached"
    TURN_OFF_HEATERS
    M84
    {% if printer["gcode_macro _USER_VARIABLES"].light_enabled %}
        LIGHT_OFF
    {% endif %}
    {% if printer["gcode_macro _USER_VARIABLES"].status_leds_enabled %}
        STATUS_LEDS COLOR="OFF"
    {% endif %}

[pause_resume]
[display_status]
[exclude_object]
[respond]

[force_move]
enable_force_move: True

[gcode_arcs]
resolution: 0.1

# -----------------------------------------------------------------------------------
# Include all the remaining files (not already included in config files) and scripts
# from here to avoid to include them in the main printer.cfg and avoid user confusion
# -----------------------------------------------------------------------------------

#[include hardware/temperature_sensors/custom_thermistors.cfg]

#[include software/shaketune.cfg]

#[include ../scripts/*.cfg]

#[include ../macros/base/*.cfg]
#[include ../macros/base/homing/homing_*.cfg]

#[include ../macros/calibration/calib*.cfg]

#[include ../macros/helpers/filament_swap.cfg]
#[include ../macros/helpers/heatsoak.cfg]
#[include ../macros/helpers/prime_line.cfg]
#[include ../macros/helpers/nozzle_cleaning.cfg]
#[include ../macros/helpers/temp_check.cfg]

#[include ../macros/miscs/compatibility.cfg]
#[include ../macros/miscs/debugging.cfg]
#[include ../macros/miscs/startup.cfg]


[stepper_x]
## config/hardware/axis/X/1.8deg.cfg
rotation_distance: 40
microsteps: 32
full_steps_per_rotation: 200

## config/hardware/axis/X/default_wiring.cfg
step_pin: X_STEP
dir_pin: X_DIR
enable_pin: !X_ENABLE
endstop_pin: X_STOP

## config/hardware/axis/X/default_speed.cfg
homing_speed: 60
homing_retract_dist: 0

## config/hardware/axis/size/350mm.cfg
position_min: 0
position_max: 350
position_endstop: 350

[stepper_y]
## config/hardware/axis/Y/1.8deg.cfg
rotation_distance: 40
microsteps: 32
full_steps_per_rotation: 200

## config/hardware/axis/Y/default_wiring.cfg
step_pin: Y_STEP
dir_pin: Y_DIR
enable_pin: !Y_ENABLE
endstop_pin: Y_STOP

## config/hardware/axis/Y/default_speed.cfg
homing_speed: 60
homing_retract_dist: 0

## config/hardware/axis/size/350mm.cfg
position_min: 0
position_max: 350
position_endstop: 350



# This probe type is for a Beacon probe used directly as a virtual Z endstop
# rather than with an existing physical endstop. To use this configuration,
# you will need to manually add the Beacon Klipper plugin!

## Then, you should just add the following two lines to your overrides and everything should work!
## The rest of the allowed config entries are available on this link: config/hardware/probes/inductive_virtual.cfg
[beacon]
serial: /dev/serial/by-id/usb-Beacon_Beacon_RevH_98B0F0CC5157355957202020FF120824-if00
x_offset: -20 # update with offset from nozzle on your machine
y_offset: 0 # update with offset from nozzle on your machine
mesh_main_direction: x
mesh_runs: 2

[gcode_macro _USER_VARIABLES]
# We can declare an "inductive_virtual" probe type as it's pretty close to the Beacon way of working and should just work!
variable_probe_type_enabled: "inductive_virtual"
variable_startprint_actions: "bed_soak", "extruder_preheating", "chamber_soak", "tilt_calib", "extruder_heating", "purge", "clean", "z_offset", "bedmesh", "primeline"
gcode:



[stepper_z]
## config/hardware/axis/Z/V2.4_stock_1.8deg.cfg
rotation_distance: 40
gear_ratio: 80:16
microsteps: 32
full_steps_per_rotation: 200

## config/hardware/axis/Z/default_wiring_1M.cfg
step_pin: Z_STEP
dir_pin: Z_DIR
enable_pin: !Z_ENABLE
endstop_pin: Z_STOP

## config/hardware/axis/Z/default_speed.cfg
homing_speed: 15
second_homing_speed: 8
homing_retract_dist: 3.0

## config/hardware/axis/size/350mm.cfg
position_max: 310
position_min: -5

## config/hardware/probes/beacon_virtual.cfg
endstop_pin: probe:z_virtual_endstop
homing_retract_dist: 0


[stepper_z1]
## config/hardware/axis/Z/V2.4_stock_1.8deg.cfg
rotation_distance: 40
gear_ratio: 80:16
microsteps: 32
full_steps_per_rotation: 200

## config/hardware/axis/Z/default_wiring_3M.cfg
step_pin: Z1_STEP
dir_pin: Z1_DIR
enable_pin: !Z1_ENABLE

[stepper_z2]
## config/hardware/axis/Z/V2.4_stock_1.8deg.cfg
rotation_distance: 40
gear_ratio: 80:16
microsteps: 32
full_steps_per_rotation: 200

## config/hardware/axis/Z/default_wiring_3M.cfg
step_pin: Z2_STEP
dir_pin: Z2_DIR
enable_pin: !Z2_ENABLE

[stepper_z3]
## config/hardware/axis/Z/V2.4_stock_1.8deg.cfg
rotation_distance: 40
gear_ratio: 80:16
microsteps: 32
full_steps_per_rotation: 200

## config/hardware/axis/Z/default_wiring_4M.cfg
step_pin: Z3_STEP
dir_pin: Z3_DIR
enable_pin: !Z3_ENABLE

## config/hardware/extruder/galileo2.cfg
[gcode_macro _USER_VARIABLES]
variable_extruder_enabled: True
gcode:


[extruder]
# Galileo 2 Gear Ratio
# new_rd = previous_rd * mesured_distance / requested_distance
rotation_distance: 47.088
gear_ratio: 9:1
microsteps: 16
full_steps_per_rotation: 200

nozzle_diameter: 0.400
filament_diameter: 1.75
max_extrude_only_distance: 110
max_extrude_cross_section: 5
sensor_type: ATC Semitec 104GT-2
min_temp: 10
max_temp: 270
max_power: 1.0
min_extrude_temp: 172
pressure_advance: 0.0475
pressure_advance_smooth_time: 0.040

## config/hardware/extruder/default_wiring.cfg
step_pin: E_STEP
dir_pin: E_DIR
enable_pin: !E_ENABLE
heater_pin: E_HEATER
sensor_pin: E_TEMPERATURE

## macros/helpers/hotend_heater_ctrl.cfg
# This file add a specific override to fix the PID controller bad behavior
# on low thermal inertia devices such as the BambuLabs hotend. This allows a
# shunt of the "waiting time" during temperature settle in case there is some problems
[gcode_macro M109]
rename_existing: M109.1
gcode:
    {% set S = params.S|float %}
    {% set actual_temp = printer.extruder.temperature|float %}

    {% set fix_heaters_temperature_settle = printer["gcode_macro _USER_VARIABLES"].fix_heaters_temperature_settle %}

    {% if fix_heaters_temperature_settle %}
        M104 {% for p in params %}{'%s%s' % (p, params[p])}{% endfor %}
        {% if S != 0 %}
            {% if actual_temp <= S %}
                TEMPERATURE_WAIT SENSOR=extruder MINIMUM={S}
            {% else %}
                TEMPERATURE_WAIT SENSOR=extruder MAXIMUM={S}
            {% endif %}   
        {% endif %}
    {% else %}
        M109.1 {% for p in params %}{'%s%s' % (p, params[p])}{% endfor %}
    {% endif %}

## config/hardware/bed_heaters/keenovo.cfg
[gcode_macro _USER_VARIABLES]
variable_heaterbed_enabled: True
gcode:


[heater_bed]
heater_pin: BED_HEATER
sensor_type: NTC 100K MGB18-104F39050L32
sensor_pin: BED_TEMPERATURE
max_power: 1
min_temp: 0
max_temp: 120

## macros/helpers/bed_heater_ctrl.cfg
# This file add a specific override to fix the PID controller bad behavior
# on low thermal inertia devices such as the BambuLabs hotend. This allows a
# shunt of the "waiting time" during temperature settle in case there is some problems
[gcode_macro M190]
rename_existing: M190.1
gcode:
    {% set S = params.S|float %}
    {% set actual_temp = printer.heater_bed.temperature|float %}

    {% set fix_heaters_temperature_settle = printer["gcode_macro _USER_VARIABLES"].fix_heaters_temperature_settle %}

    {% if fix_heaters_temperature_settle %}
        M140 {% for p in params %}{'%s%s' % (p, params[p])}{% endfor %}
        {% if S != 0 %}
            {% if actual_temp <= S %}
                TEMPERATURE_WAIT SENSOR=heater_bed MINIMUM={S}
            {% else %}
                TEMPERATURE_WAIT SENSOR=heater_bed MAXIMUM={S}
            {% endif %}   
        {% endif %}
    {% else %}
        M190.1 {% for p in params %}{'%s%s' % (p, params[p])}{% endfor %}
    {% endif %}



## macros/base/probing/generic_probe.cfg
# This file is used as in interface to activate/deactivate every probe type
# depending of the needs:
#  - TAP: need to be at a correct nozzle temperature to avoid burning the PEI when used
#  - Dockable probe: need to be attached/docked when used
#  - ... can be improved depending of new probes needs ...

[gcode_macro ACTIVATE_PROBE]
description: Put the machine in a state being able to probe
variable_temperature: 0
gcode:
    {% set LOCK = params.LOCK|default(False, boolean=true) %}

    {% set probe_type_enabled = printer["gcode_macro _USER_VARIABLES"].probe_type_enabled %}
    {% set tap_max_probing_temp = printer["gcode_macro _USER_VARIABLES"].tap_max_probing_temp|float %}

    # If a dockable probe is defined, then check and ATTACH the probe
    {% if probe_type_enabled == "dockable" or probe_type_enabled == "dockable_virtual" %}
        _CHECK_PROBE action=query
        {% if LOCK %}
            _ATTACH_PROBE_LOCK
        {% else %}
            _ATTACH_PROBE
        {% endif %}

    # If a Voron TAP probe is defined, then check the temperature and lower it if needed
    {% elif probe_type_enabled == "vorontap" %}
        SAVE_GCODE_STATE NAME=BEFORE_TAP_ACTION

        {% set ACTUAL_TEMP = printer.extruder.temperature %}
        {% set TARGET_TEMP = printer.extruder.target %}

        SET_GCODE_VARIABLE MACRO=ACTIVATE_PROBE VARIABLE=temperature VALUE={TARGET_TEMP}

        {% if TARGET_TEMP > tap_max_probing_temp %}
            { action_respond_info('Extruder temperature target of %.1fC is too high for TAP probing, lowering to %.1fC' % (TARGET_TEMP, tap_max_probing_temp)) }
            M106 S255 ; 100% the part cooling fan to help the extruder cooling
            M109 S{tap_max_probing_temp}
            M106 S0   ; Stop the part cooling fan
        {% else %}
            # Temperature target is already low enough, but nozzle may still be too hot
            {% if ACTUAL_TEMP > tap_max_probing_temp + 3 %}
                M106 S255 ; 100% the part cooling fan to help the extruder cooling
                TEMPERATURE_WAIT SENSOR=extruder MAXIMUM={tap_max_probing_temp}
                M106 S0   ; Stop the part cooling fan
            {% endif %}
        {% endif %}
    {% endif %}


[gcode_macro DEACTIVATE_PROBE]
description: Revert the machine to a normal state after probing
gcode:
    {% set UNLOCK = params.UNLOCK|default(False, boolean=true) %}

    {% set probe_type_enabled = printer["gcode_macro _USER_VARIABLES"].probe_type_enabled %}
    {% set tap_deactivation_zhop = printer["gcode_macro _USER_VARIABLES"].tap_deactivation_zhop %}
    {% set Sz = printer["gcode_macro _USER_VARIABLES"].z_drop_speed * 60 %}

    # If a dockable probe is defined, then check and DETTACH the probe
    {% if probe_type_enabled == "dockable" or probe_type_enabled == "dockable_virtual" %}
        _CHECK_PROBE action=query
        {% if UNLOCK %}
            _DOCK_PROBE_UNLOCK
        {% else %}
            _DOCK_PROBE
        {% endif %}

    # If a Voron TAP probe is defined, then check and restore the nozzle temperature if needed
    {% elif probe_type_enabled == "vorontap" %}
        # Small Z hop to avoid restoring the temperature directly on the PEI
        {% set z_safe = printer.toolhead.position.z + tap_deactivation_zhop %}
        {% if z_safe > printer.toolhead.axis_maximum.z %}
            {% set z_safe = printer.toolhead.axis_maximum.z %}
        {% endif %}
        G90
        G1 Z{z_safe} F{Sz}

        # Then restoring the temperature
        {% set old_target_temperature = printer["gcode_macro ACTIVATE_PROBE"].temperature %}
        M109 S{old_target_temperature}

        RESTORE_GCODE_STATE NAME=BEFORE_TAP_ACTION
    {% endif %}

## config/hardware/fans/hotend_fan.cfg
[heater_fan hotend_fan]
pin: E_FAN
max_power: 1.0
kick_start_time: 0.100
heater: extruder
heater_temp: 50.0

## config/hardware/fans/part_fan.cfg
[fan]
pin: PART_FAN
kick_start_time: 0.100
cycle_time: 0.010

## config/hardware/fans/hotend_fan_tachometer.cfg
[gcode_macro _USER_VARIABLES]
variable_hotend_fan_tach_enabled: True
gcode:

[heater_fan hotend_fan]
pin: E_FAN
max_power: 1.0
kick_start_time: 0.100
heater: extruder
heater_temp: 50.0
tachometer_pin: E_FAN_TACHO

## macros/helpers/tachometer_check.cfg
## This config file contains macros that are used in conjuction with tacho-enabled hotend and part fans
# Monitoring loop for hotend fan safety check
[delayed_gcode _BACKGROUND_HOTEND_TACHO_CHECK]
gcode:
    _HOTEND_FAN_CHECK
    UPDATE_DELAYED_GCODE ID=_BACKGROUND_HOTEND_TACHO_CHECK DURATION=3

[gcode_macro _HOTEND_FAN_CHECK]
description: Check the hotend fan tachometer to verify that it is running effectively
variable_he_stop_count: 0
gcode:
    {% set min_rpm = 1000|float %} # This is a relatively low value adapted to all fans to check that they are effectively running
    {% set max_consecutive_stops = 3 %}
    {% set rpm = printer['heater_fan hotend_fan'].rpm|float %}
    {% set he_target = printer[printer.toolhead.extruder].target|float %}
    {% set he_temp = printer[printer.toolhead.extruder].temperature|float %}
    {% set fan_on_temp = printer.configfile.settings['heater_fan hotend_fan'].heater_temp|float %}
    {% set he_stop_count = printer["gcode_macro _HOTEND_FAN_CHECK"].he_stop_count|int %}

    {% if (he_target >= fan_on_temp) and (rpm < min_rpm) and (he_temp >= fan_on_temp) %}
        SET_GCODE_VARIABLE MACRO=_HOTEND_FAN_CHECK VARIABLE=he_stop_count VALUE={he_stop_count + 1}
        RESPOND MSG="Hotend fan stoppage detected for {(he_stop_count+1)*3}sec (max {max_consecutive_stops*3}sec allowed)"
        M400
        {% if printer["gcode_macro _HOTEND_FAN_CHECK"].he_stop_count|int >= max_consecutive_stops-1 %}
            CANCEL_PRINT
        {% endif %}
    {% else %}
        SET_GCODE_VARIABLE MACRO=_HOTEND_FAN_CHECK VARIABLE=he_stop_count VALUE=0
    {% endif %}


[gcode_macro _PART_FAN_CHECK]
description: Check the part fan tachometer to verify that it is running effectively
gcode:
    {% if printer.fan.rpm is not none %}
        {% if printer.fan.rpm > 1000 %} # This is a relatively low value adapted to all fans to check that they are effectively running
            {action_respond_info("Part fan OK!")}
        {% else %}
            M400
            CANCEL_PRINT
            {action_raise_error("Hotend fan stoppage detected, print was canceled!")}
        {% endif %}
    {% endif %}

## config/hardware/temperature_sensors/rpi_temp.cfg
[temperature_sensor Raspberry_Pi]
sensor_type: temperature_host

## config/hardware/temperature_sensors/mcu_temp.cfg
[temperature_sensor mcu]
sensor_type = temperature_mcu
min_temp = 0
max_temp = 90

## config/hardware/temperature_sensors/toolhead_mcu_temp.cfg
[temperature_sensor toolhead_mcu]
sensor_type: temperature_mcu
sensor_mcu: toolhead
min_temp = 0
max_temp = 100

## config/hardware/filament_sensors/switch_sensor.cfg
[gcode_macro _USER_VARIABLES]
variable_filament_sensor_enabled: True
gcode:

[filament_switch_sensor runout_sensor]
switch_pin: RUNOUT_SENSOR
pause_on_runout: True
#runout_gcode:
#insert_gcode:
#event_delay:
#pause_delay:

## config/software/bed_mesh/bed_mesh_350mm.cfg
# If this files is included, then it also activate the bed_mesh
# automatically in the START_PRINT macro
[gcode_macro _USER_VARIABLES]
variable_bed_mesh_enabled: True
gcode:

[bed_mesh]
speed: 350
horizontal_move_z: 20
mesh_min: 25, 25
mesh_max: 325, 325
probe_count: 9, 9
fade_start: 0.6
fade_end: 10.0
algorithm: bicubic
zero_reference_position: 175, 175

## macros/base/probing/overrides/bed_mesh_calibrate.cfg
#############################################################################
# Dockable probe macros highly inspired from https://github.com/jlas1/Klicky-Probe
# Reworked by Elpopo and myself to simplify it while trying to stay generic
#############################################################################

[gcode_macro BED_MESH_CALIBRATE]
rename_existing: _BASE_BED_MESH_CALIBRATE
description: Perform Mesh Bed Leveling with klicky automount
gcode:
    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}
    {% set probe_type_enabled = printer["gcode_macro _USER_VARIABLES"].probe_type_enabled %}

    {% if verbose %}
        { action_respond_info("Bed Mesh Calibrate") }
    {% endif %}
    _CG28

    ACTIVATE_PROBE

    {% if probe_type_enabled == "dockable" %}
        SET_GCODE_VARIABLE MACRO=_PROBE_ON_ERROR_ACTION VARIABLE=probing VALUE=True
    {% endif %}

    _BASE_BED_MESH_CALIBRATE  {% for p in params %}{'%s=%s ' % (p, params[p])}{% endfor %}

    {% if probe_type_enabled == "dockable" %}
        SET_GCODE_VARIABLE MACRO=_PROBE_ON_ERROR_ACTION VARIABLE=probing VALUE=False
    {% endif %}

    DEACTIVATE_PROBE

## macros/calibration/adaptive_bed_mesh.cfg
#########################################
########## ADAPTIVE BED MESH ############
#########################################
# Written by Frix_x#0161 #
# @version: 4.0

# CHANGELOG:
#   v4.0: - patched and re-simplified the macro to work with latest Klipper changes: zero_reference_position is much more constrained and all the fancy stuff
#           that was used in the past for homing over the RRI with virtual probe or Z calibration plugin is not possible anymore. Now homing must be done at
#           fixed zero_reference_poisition and can't be dynamic anymore (but it's also simpler)
#         - this change also allow the mesh to have even probe point now for more flexibility
#   v3.0: - added the use of [exclude_object] tags to extract the first layer bounding box (many thanks to Kyleisah for the excellent idea and inspiration)
#           the macro is still fully compatible with the old way using the SIZE parameter: it will use it if specified, or else
#           fallback to the [exclude_object] method and if both are not available, it will do a full and normal bed mesh as usual.
#         - also added a FORCE_MESH parameter to mesh even for very small parts
#         - removed the RRI that was always added put in the BED_MESH_CALIBRATE call. Now it's added only when there is one defined in the [bed_mesh] section
#   v2.3: moved the install notes into a proper markdown file in: docs > features > adaptive_bed_mesh.md
#   v2.2: removed the requirement to set mesh_pps in the [bed_mesh] section. It's now again optional as it should be
#   v2.1: fix for the nominal mesh (when no SIZE parameter is used or SIZE=0_0_0_0)
#   v2.0: split in multple macros to be able to use the center point in the z calibration bed probing position before doing the mesh
#   v1.1: fix for a bug when parsing string when using uppercase letters in the [bed_mesh] section
#   v1.0: first adaptive bed mesh macro

# -------------------------------------------------------------------------------------------------------------------------
# If you want to use it into your own config, please install it as a standalone macro as described in the
# installation section of this file: docs > features > adaptive_bed_mesh.md
# -------------------------------------------------------------------------------------------------------------------------

### What is it ? ###
# The adaptive bed mesh is simple: it's a normal bed mesh, but only "where" and "when" it's necessary.
# Sometime I print small parts, sometime I print full plates and I like to get a precise bed_mesh (like 9x9 or more). However, it take a
# lot of time and it's useless to probe all the plate for only a 5cm² part. So this is where the adaptive bed mesh is helping:
# 1. It get the corners coordinates of the fisrt layer surface either from the slicer or the [exclude_object] tags
# 2. It compute a new set of points to probe on this new zone to get at least the same precision as your standard bed mesh. For example, if
#    a normal bed mesh is set to 9x9 for 300mm², it will then compute 3x3 for a 100mm² surface. Also if for whatever reason your parts are in
#    the corner of the build plate (like for a damaged PEI in the center), it will follow them to probe this exact area.
# 3. To go further, it will not do any bed_mesh if there is less than 3x3 points to probe (very small part alone) and choose/change the
#    algorithm (bicubic/lagrange) depending of the size and shape of the mesh computed (like 3x3 vs 3x9)

# Feel free to ping me on Discord (Frix_x#0161) if you need help or have any comments to improve it :)


# ===========================================================================================================
# DO NOT MODIFY THOSE VARIABLES (they are used internaly by the adaptive bed mesh macro)
[gcode_macro _ADAPTIVE_MESH_VARIABLES]
variable_ready: False
variable_do_mesh: False
variable_do_nominal: False
variable_mesh_min: 0,0
variable_mesh_max: 0,0
variable_probe_count: 0,0
variable_algo: "bicubic"
gcode:


[gcode_macro COMPUTE_MESH_PARAMETERS]
description: Compute the mesh parameters and store them for later use
gcode:
    # 1 ----- GET ORIGINAL BEDMESH PARAMS FROM CONFIG ----------------------
    {% set xMinConf, yMinConf = printer["configfile"].config["bed_mesh"]["mesh_min"].split(',')|map('trim')|map('int') %}
    {% set xMaxConf, yMaxConf = printer["configfile"].config["bed_mesh"]["mesh_max"].split(',')|map('trim')|map('int') %}
    {% set xProbeCntConf, yProbeCntConf = printer["configfile"].config["bed_mesh"]["probe_count"].split(',')|map('trim')|map('int') %}
    {% set algo = printer["configfile"].config["bed_mesh"]["algorithm"]|lower %}
    {% set xMeshPPS, yMeshPPS = (printer["configfile"].config["bed_mesh"]["mesh_pps"]|default('2,2')).split(',')|map('trim')|map('int') %}

    {% set margin = params.MARGIN|default(5)|int %} # additional margin to mesh around the first layer
    {% set force_mesh = params.FORCE_MESH|default(False) %} # force the mesh even if it's a small part (ie. computed less than 3x3)


    # 2 ----- GET FIRST LAYER COORDINATES and SIZE -------------------------------------
    # If the SIZE parameter is defined and not a dummy placeholder, we use it to do the adaptive bed mesh logic
    {% set coordinatesFound = false %}
    {% if params.SIZE is defined and params.SIZE != "0_0_0_0" %}
        RESPOND MSG="Got a SIZE parameter for the adaptive bed mesh"
        {% set xMinSpec, yMinSpec, xMaxSpec, yMaxSpec = params.SIZE.split('_')|map('trim')|map('int') %}
        {% set coordinatesFound = true %}

    {% elif printer.exclude_object is defined %}
        {% if printer.exclude_object.objects %}
            # Else if SIZE is not defined, we fallback to use the [exclude_object] tags
            # This method is derived from Kyleisah KAMP repository: https://github.com/kyleisah/Klipper-Adaptive-Meshing-Purging)
            RESPOND MSG="No SIZE parameter, using the [exclude_object] tags for the adaptive bed mesh"
            {% set eo_points = printer.exclude_object.objects|map(attribute='polygon')|sum(start=[]) %}
            {% set xMinSpec = eo_points|map(attribute=0)|min %}
            {% set yMinSpec = eo_points|map(attribute=1)|min %}
            {% set xMaxSpec = eo_points|map(attribute=0)|max %}
            {% set yMaxSpec = eo_points|map(attribute=1)|max %}
            {% set coordinatesFound = true %}
        {% endif %}
    {% endif %}

    {% if not coordinatesFound %}
        # If no SIZE parameter and no [exclude_object] tags, then we want to do a nominal bed mesh
        # so nothing to do here...
        RESPOND MSG="No info about the first layer coordinates, doing a nominal bed mesh instead of adaptive"
    {% endif %}


    # If the first layer size was correctly retrieved, we can do the adaptive bed mesh logic, else we
    # fallback to the original and nominal BED_MESH_CALIBRATE function (full bed probing)
    {% if xMinSpec and yMinSpec and xMaxSpec and yMaxSpec %}

        # 3 ----- APPLY MARGINS ----------------------------------------------
        # We use min/max function as we want it to be constrained by the original
        # bedmesh size. This will avoid going outside the machine limits
        {% set xMin = [xMinConf, (xMinSpec - margin)]|max %}
        {% set xMax = [xMaxConf, (xMaxSpec + margin)]|min %}
        {% set yMin = [yMinConf, (yMinSpec - margin)]|max %}
        {% set yMax = [yMaxConf, (yMaxSpec + margin)]|min %}

        # 4 ----- COMPUTE A NEW PROBE COUNT ----------------------------------
        # The goal is to have at least the same precision as from the config. So we compute an equivalent number
        # of probe points on each X/Y dimensions (distance between two points should be the same as in the config)
        {% set xProbeCnt = ((xMax - xMin) * xProbeCntConf / (xMaxConf - xMinConf))|round(0, 'ceil')|int %}
        {% set yProbeCnt = ((yMax - yMin) * yProbeCntConf / (yMaxConf - yMinConf))|round(0, 'ceil')|int %}

        # Then, three possibilities :
        # a) Both dimensions have less than 3 probe points : the bed_mesh is not needed as it's a small print (if not forced).
        # b) If one of the dimension is less than 3 and the other is greater. The print looks to be elongated and
        #    need the adaptive bed_mesh : we add probing points to the small direction to reach 3 and be able to do it.
        # c) If both direction are greater than 3, we need the adaptive bed_mesh and it's ok.
        # At the end we control (according to Klipper bed_mesh method: "_verify_algorithm") that the computed probe_count is
        # valid according to the choosen algorithm or change it if needed.
        {% if xProbeCnt < 3 and yProbeCnt < 3 %}
            {% if force_mesh %}
                RESPOND MSG="Bed mesh forced (small part detected): meshing 3x3..."
                {% set xProbeCnt = 3 %}
                {% set yProbeCnt = 3 %}
                {% set algo = "lagrange" %}
                {% set mesh_min = "%d,%d"|format(xMin, yMin) %}
                {% set mesh_max = "%d,%d"|format(xMax, yMax) %}
                {% set probe_count = "%d,%d"|format(xProbeCnt, yProbeCnt) %}
                RESPOND MSG="Computed mesh parameters: MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} ALGORITHM={algo}"
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_mesh VALUE={True}
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_nominal VALUE={False}
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=mesh_min VALUE='"{mesh_min}"'
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=mesh_max VALUE='"{mesh_max}"'
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=probe_count VALUE='"{probe_count}"'
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=algo VALUE='"{algo}"'
            {% else %}
                RESPOND MSG="Computed mesh parameters: none, bed mesh not needed for very small parts"
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_mesh VALUE={False}
            {% endif %}
        {% else %}
            {% set xProbeCnt = [3, xProbeCnt]|max %}
            {% set yProbeCnt = [3, yProbeCnt]|max %}

            # Check of the probe points and interpolation algorithms according to Klipper code
            {% if xMeshPPS != 0 or yMeshPPS != 0 %}
                {% set probeCntMin = [xProbeCnt, yProbeCnt]|min %}
                {% set probeCntMax = [xProbeCnt, yProbeCnt]|max %}
                {% if algo == "lagrange" and probeCntMax > 6 %}
                    # Lagrange interpolation tends to oscillate when using more than 6 samples: swith to bicubic
                    {% set algo = "bicubic" %}
                {% endif %}
                {% if algo == "bicubic" and probeCntMin < 4 %}
                    {% if probeCntMax > 6 %}
                        # Impossible case: need to add probe point on the small axis to be >= 4 (we want 5 to keep it odd)
                        {% if xProbeCnt > yProbeCnt %}
                            {% set yProbeCnt = 5 %}
                        {% else %}
                            {% set xProbeCnt = 5 %}
                        {% endif %}
                    {% else %}
                        # In this case bicubic is not adapted (less than 4 points): switch to lagrange
                        {% set algo = "lagrange" %}
                    {% endif %}
                {% endif %}
            {% endif %}

            # 5 ----- FORMAT THE PARAMETERS AND SAVE THEM ---------------------------
            {% set mesh_min = "%d,%d"|format(xMin, yMin) %}
            {% set mesh_max = "%d,%d"|format(xMax, yMax) %}
            {% set probe_count = "%d,%d"|format(xProbeCnt, yProbeCnt) %}
            RESPOND MSG="Computed mesh parameters: MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} ALGORITHM={algo}"
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_mesh VALUE={True}
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_nominal VALUE={False}
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=mesh_min VALUE='"{mesh_min}"'
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=mesh_max VALUE='"{mesh_max}"'
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=probe_count VALUE='"{probe_count}"'
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=algo VALUE='"{algo}"'
        {% endif %}
    {% else %}
        SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_mesh VALUE={True}
        SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_nominal VALUE={True}
    {% endif %}

    # Finaly save in the variables that we already computed the values
    SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=ready VALUE={True}


[gcode_macro ADAPTIVE_BED_MESH]
description: Perform a bed mesh, but only where and when it's needed
gcode:
    {% set ready = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].ready %}

    {% if not 'xyz' in printer.toolhead.homed_axes %}
        { action_raise_error("Must Home printer first!") }
    {% endif %}

    # If the parameters where computed, we can do the mesh by calling the _DO_ADAPTIVE_MESH
    {% if ready %}
        _DO_ADAPTIVE_MESH

    # If the parameters where not computed prior to the ADAPTIVE_BED_MESH call, we call the COMPUTE_MESH_PARAMETERS
    # macro first and then call the _DO_ADAPTIVE_MESH macro after it
    {% else %}
        RESPOND MSG="Adaptive bed mesh: parameters not already computed, automatically calling the COMPUTE_MESH_PARAMETERS macro prior to the mesh"
        COMPUTE_MESH_PARAMETERS {rawparams}
        M400 # mandatory to flush the gcode buffer and be sure to use the last computed parameters
        _DO_ADAPTIVE_MESH
    {% endif %}


[gcode_macro _DO_ADAPTIVE_MESH]
gcode:
    # 1 ----- POPULATE BEDMESH PARAMS FROM SAVED VARIABLES ----------------------
    {% set do_mesh = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].do_mesh %}
    {% set do_nominal = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].do_nominal %}
    {% set mesh_min = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].mesh_min %}
    {% set mesh_max = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].mesh_max %}
    {% set probe_count = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].probe_count %}
    {% set algo = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].algo %}

    # 2 --------- ADAPTIVE_BED_MESH LOGIC --------------------------------------

    # If it's necessary to do a mesh
    {% if do_mesh %}
        # If it's a standard bed_mesh to be done
        {% if do_nominal %}
            RESPOND MSG="Adaptive bed mesh: nominal bed mesh"
            BED_MESH_CALIBRATE
        {% else %}
                RESPOND MSG="Adaptive bed mesh: MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} ALGORITHM={algo}"
                BED_MESH_CALIBRATE MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} ALGORITHM={algo}
        {% endif %}
    {% else %}
        RESPOND MSG="Adaptive bed mesh: no mesh to be done"
    {% endif %}

    # Set back the 'ready' parameter to false
    SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=ready VALUE={False}

## config/software/tilting/qgl_350mm.cfg
# Quad gantry leveling definition
# If this files is included, then it also activate the QGL
# automatically in the START_PRINT macro
[gcode_macro _USER_VARIABLES]
variable_qgl_enabled: True
gcode:

[quad_gantry_level]
gantry_corners:
    -60,-10
    410,420
points:
    50,25
    50,275
    300,275
    300,25
speed: 350
horizontal_move_z: 12
retries: 5
retry_tolerance: 0.0075
max_adjust: 10


## macros/base/probing/overrides/qgl.cfg
#############################################################################
# Dockable probe macros highly inspired from https://github.com/jlas1/Klicky-Probe
# Reworked by Elpopo and myself to simplify it while trying to stay generic
#############################################################################

[gcode_macro QUAD_GANTRY_LEVEL]
rename_existing: _BASE_QUAD_GANTRY_LEVEL
description: Conform a moving, twistable gantry to the shape of a stationary bed with klicky automount
gcode:
    {% set tilting_travel_accel = printer["gcode_macro _USER_VARIABLES"].tilting_travel_accel %}
    {% set status_leds_enabled = printer["gcode_macro _USER_VARIABLES"].status_leds_enabled %}
    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}

    {% if verbose %}
        { action_respond_info("Quad gantry leveling") }
    {% endif %}

    _CG28
    
    {% if status_leds_enabled %}
        STATUS_LEDS COLOR="LEVELING"
    {% endif %}

    ACTIVATE_PROBE

    # Set the tilting acceleration prior to any movement
    {% set saved_accel = printer.toolhead.max_accel %}
    M204 S{tilting_travel_accel}

    _BASE_QUAD_GANTRY_LEVEL {% for p in params %}{'%s=%s ' % (p, params[p])}{% endfor %}
    
    # Reset acceleration values to what it was before
    SET_VELOCITY_LIMIT ACCEL={saved_accel}

    DEACTIVATE_PROBE

    {% if status_leds_enabled %}
        STATUS_LEDS COLOR="READY"
    {% endif %}

## macros/base/homing/tilting.cfg
[gcode_macro _TILT_CALIBRATE]
description: Do a QGL, Z_tilt, etc... depending of the machine configuration
gcode:
    {% set FORCE_OPERATION = params.FORCE|default('true') %}
    {% set conf_QGL = printer["gcode_macro _USER_VARIABLES"].qgl_enabled %}
    {% set conf_ztilt = printer["gcode_macro _USER_VARIABLES"].ztilt_enabled %}
    {% set probe_type_enabled = printer["gcode_macro _USER_VARIABLES"].probe_type_enabled %}
    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}

    {% if probe_type_enabled == "dockable" %}
        SET_GCODE_VARIABLE MACRO=_PROBE_ON_ERROR_ACTION VARIABLE=probing VALUE=True
    {% endif %}

    {% if conf_QGL %}
        {% if printer.quad_gantry_level.applied|lower == 'false' or FORCE_OPERATION|lower == 'true' %}
            {% if verbose %}
                RESPOND MSG="QGL..."
            {% endif %}
            QUAD_GANTRY_LEVEL
        {% endif %}
    {% elif conf_ztilt %}
        {% if printer.z_tilt.applied|lower == 'false' or FORCE_OPERATION|lower == 'true' %}
            {% if verbose %}
                RESPOND MSG="Z tilt adjust..."
            {% endif %}
            Z_TILT_ADJUST
        {% endif %}
    {% else %}
        {% if verbose %}
            RESPOND MSG="No tilt calibration needed on this machine. Continuing..."
        {% endif %}
    {% endif %}

    {% if probe_type_enabled == "dockable" %}
        SET_GCODE_VARIABLE MACRO=_PROBE_ON_ERROR_ACTION VARIABLE=probing VALUE=False
    {% endif %}

## user_templates/variables.cfg
[gcode_macro _USER_VARIABLES]
# Enable verbose output to let the macro have a chat
variable_verbose: True

###################################################
# Feedrate and accels setpoints for all the macros
###################################################

## SPEEDS
variable_homing_travel_speed: 350
variable_travel_speed: 350
variable_z_drop_speed: 15
variable_brush_clean_speed: 100
variable_probe_dock_speed: 60

## ACCELS
## Those are specific accel settings for some of the macros
variable_homing_travel_accel: 3000
variable_tilting_travel_accel: 3000
variable_brush_clean_accel: 1500
variable_probe_dock_accel: 2000


#####################################################
# Homing, start_print, end_print and pause variables
#####################################################

## Physical Z endstop pin position. This variable is used only if
## you don't use the automatic z_calibration plugin: if this plugin is
## installed, the z endstop pin position is directly extracted from the
## plugin config file (see config/software/z_calibration.cfg) or its user override.
variable_zendstop_position: -1, -1 # change it ONLY if not using the auto z calibration plugin !!!

## Force always a full homing and QGL/Z_TILT during the START_PRINT macro
variable_force_homing_in_start_print: False

## Z hop before homing to avoid grinding
## the bed due to the gantry sag
variable_homing_zhop: 5

## XY axis homing order and backoff distance after touching the endstops
variable_homing_first: "X" # can be set to "Y" first
variable_homing_backoff_distance_xy: -5, -5 # move 5mm in negative direction on both axis

## Percentage of run_current used while sensorless homing (if used)
variable_sensorless_current_factor: 75

## margin to avoid the probe dock when homing
variable_probe_dock_margin_xy: 0, 0

## Temperature of the extruder used to preheat the chamber temperature and do some START_PRINT actions
variable_safe_extruder_temp: 150

## Prime line parameters
variable_prime_line_xy: 5, 2.5 # starting point
variable_prime_line_direction: "X" # can also be set to "Y"
variable_prime_line_length: 40 # length of the prime line on the bed (in mm)
variable_prime_line_purge_distance: 30 # length of filament to purge (in mm)
variable_prime_line_flowrate: 10 # mm3/s used for the prime line
variable_prime_line_height: 0.6 # mm, used for actual cross section computation
variable_prime_line_margin: 5  # distance of purge line from fl_size rectangle
variable_prime_line_wipe: False # enable a wipe of the nozzle after completing the prime line

## Length of filament to retract to disengage it from the heatbreak.
## This is to reduce final print oozing, but also to prevent heatcreep, clogging, and allow cold filament change between prints.
## Unretract is the length of filament to prime and pressurize the nozzle prior to printing. 
## This is recommended to be 10-20% more than the retract value.
variable_retract_length: 20
variable_unretract_length: 23

## Park position used when pause, end_print, etc...
variable_park_position_xy: -1, -1
variable_park_lift_z: 50

## Automatically disable motors in the END_PRINT macro
variable_disable_motors_in_end_print: False

## Automatically turn-off heaters in the END_PRINT macro
variable_turn_off_heaters_in_end_print: True

## Set idle timeout duration when a print job is paused. 0 means no change
variable_idle_timeout_on_pause: 0


#########################################################
# Dockable probe variables (if available in the machine)
#########################################################

## Bed size used to avoids doing a probe_accuracy or probe_calibrate outside the bed
## This has no effect in the macros beside a safety check (not mandatory to be changed)
variable_min_bed_xy: 0, 0
variable_max_bed_xy: 9999, 9999

## Minimum safe Z height to attach/detach probe
variable_probe_min_z_travel: 20

## Z height to move to when detaching probe
## Setting to 'None' or removing this variable will prevent any
## change in z position when detaching the probe 
variable_probe_stow_z_height: None

## Position of the probe dock
variable_probe_dock_location_xy: -1, -1

## Servo angles used to define the retracted and deployed positions
## of the dock (if applicable). These variables are only used if a probe servo
## is included in the config and have no effect if it's not the case
variable_probe_servo_angle_retracted: 0
variable_probe_servo_angle_deployed: 90

## Positions of the toolhead when docking/undocking the probe
## See diagram below for help
variable_probe_before_attach_position: "front"
variable_probe_after_attach_position : "front"
variable_probe_before_dock_position : "front" # generaly same as probe_after_attach_position
variable_probe_after_dock_position : "left"

variable_probe_move_attach_length: 30
variable_probe_move_dock_length: 30

##    Y
##    ^ 
##    |          back
##    |           ^
##    |   left  < O >  right
##    |           v
##    |         front
##    |_ _ _ _ _ _ _ _ _ _ _ _> X

## If there is an error during a tilting procedure (QGL or Z_TILT_ADJUST) or during a BED_MESH_CALIBRATE
## then automatically dock the probe before stopping all actions. This avoid letting the probe
## very close to a very hot bed doing nothing as this could destroy the probe microswitch
variable_autodock_on_probe_error: True


##########################################################
# Voron TAP probe variables (if available in the machine)
##########################################################

variable_tap_max_probing_temp: 150
variable_tap_deactivation_zhop: 5 # this is used to Z hop before restoring the temperature to avoid burnt PEI


##########################################
# Material and specific print parameters
##########################################

## default START_PRINT parameters
variable_print_default_bed_temp: 105
variable_print_default_extruder_temp: 240
variable_print_default_chamber_temp: 0
variable_print_default_chamber_max_heating_time: 15
variable_print_default_soak: 8
variable_print_default_material: "XXX"

## Material configuration parameters applied during START_PRINT by using the slicer MATERIAL variable
## FYI, retract paramaters are used only if firmware retraction is enabled, filter speed (in %) is used if
## there is a filter installed on the machine, filament sensor is on or off if installed, etc...
## If you are using another material, just extend the list bellow with a new material and everything should work :)
variable_material_parameters: {
        'PLA': {
            'pressure_advance': 0.0525,
            'retract_length': 0.75,
            'unretract_extra_length': 0,
            'retract_speed': 40,
            'unretract_speed': 30,
            'filter_speed': 0,
            'additional_z_offset': 0,
            'filament_sensor': 1
        },
        'PET': {
            'pressure_advance': 0.0650,
            'retract_length': 1.4,
            'unretract_extra_length': 0,
            'retract_speed': 30,
            'unretract_speed': 20,
            'filter_speed': 0,
            'additional_z_offset': 0.020,
            'filament_sensor': 1
        },
        'ABS': {
            'pressure_advance': 0.0480,
            'retract_length': 0.5,
            'unretract_extra_length': 0,
            'retract_speed': 40,
            'unretract_speed': 30,
            'filter_speed': 80,
            'additional_z_offset': 0,
            'filament_sensor': 1
        },
        'TPU': {
            'pressure_advance': 0.0500,
            'retract_length': 0.2,
            'unretract_extra_length': 0,
            'retract_speed': 5,
            'unretract_speed': 5,
            'filter_speed': 0,
            'additional_z_offset': 0.040,
            'filament_sensor': 0
        }
    }


################################################
## MMU/ERCF specific variables
################################################
## This section is only considered if an MMU/ERCF is installed and configured

variable_mmu_force_homing_in_start_print: False
variable_mmu_unload_on_cancel_print: False
variable_mmu_unload_on_end_print: True
variable_mmu_check_gates_on_start_print: False   # True is recommended but you must have TOOLS_USED=!referenced_tools! in your slicer START_PRINT parameters. Otherwise it will only check the INITIAL TOOL...
variable_mmu_check_errors_on_start_print: False  # Set to True if you want an early check of MMU errors during the START_PRINT sequence.

################################################
## Filter specific variables
################################################
## This section is only considered if a filter is available (and enabled)

variable_filter_default_time_on_end_print: 600 # seconds

################################################
# Other hardware options used in the macros
################################################

## Brush and purge bucket available in the machine
## If this is not available in the machine, set both positions
## variables to "-1, -1, -1" for safety
variable_purge_and_brush_enabled: False
variable_force_homing_before_brush: False # Add an homing of the Z axis before a clean to be sure to not miss the brush
variable_brush_over_y_axis: True # Cleanup is done moving the extruder along the Y axis, then X axis. If false, only X axis is done
variable_brush_xyz: -1, -1, -1 # Position of the brush center for nozzle cleaning
variable_brush_width_x: 40 # Width of the brush in X direction (in mm)
variable_brush_center_offset: 0 # Offset of the brush center to start brushing (in mm), + is towards max X
variable_brushes: 6 # Number of brushes of the nozzle to perform
variable_purge_bucket_xyz: -1, -1, -1 # Purge bucket position
variable_purge_distance: 30 # Amount to purge (in mm)
variable_purge_ooze_time: 10 # Time (in seconds) to wait after the purge to let the nozzle ooze before going to the brush

## Servo angles used to define the retracted and deployed positions
## of the purge bucket and brush (if applicable). These variables are only used if a purge
## bucket servo is included in the config and have no effect if it's not the case
variable_purgeclean_servo_angle_retracted: 0
variable_purgeclean_servo_angle_deployed: 90

## White light parameters (if installed in the machine)
variable_light_intensity_start_print: 100
variable_light_intensity_printing: 30
variable_light_intensity_end_print: 0

## Caselight LEDs ON at startup (caselight need to be installed in the machine)
variable_caselight_on_at_startup: False

## Patch the M190/M109 commands to avoid some wait time while the temperature
## settle on very low thermal latency devices (such as the BambuLabs hotend)
variable_fix_heaters_temperature_settle: False

## Resonnance testing position (if an accelerometer is installed in the machine)
## If test point is let to -1,-1, it default to the center of the bed at 50mm high
variable_resonnance_test_point_xy: -1, -1
variable_resonnance_test_z_clearance: 50


## -----------------------------------------------------------------------------------
## -----------------------------------------------------------------------------------
## Do not remove the next lines
gcode:

[save_variables]
filename: ~/printer_data/config/save_variables.cfg

## user_templates/mcu.cfg
######################################################### \
#### User MCU and TMCs wiring definition file ###########  + --> Everything MCU related :)
######################################################### /

# This file is yours: keep in mind that it will not be erased when updating
# the config using moonraker and it will be kept as you've set it.

# Put here all your wiring definitions, your MCU serial port, CANbus UUID, etc...
# It should be populated automatically with some default wiring templates during
# the first time install of the config if you choose to do so when asked by the
# script. If it's not the case, you will need to manually define all your
# [board_pins] section. You can use the pinout documentation here: ./docs/pinout.md

# ------------------------------------------------------------------------------------------


#-------------------------#
#   TMCs DRIVERS          #
#-------------------------#

# ---------------------------------------------------------------------- AXIS DRIVERS ----> optional, but only one line per axis need to be selected
### 1. X Drivers -------------------------------------------------------------------------
# [include config/hardware/axis/X/TMC/TMC2209.cfg]
# [include config/hardware/axis/X/TMC/TMC2209_V0specific.cfg] # Should only be used for early LDO V0 kits to mitigate the known VFAs issue
# [include config/hardware/axis/X/TMC/TMC2240.cfg]
# [include config/hardware/axis/X/TMC/TMC5160.cfg]
### 2. Y Drivers -------------------------------------------------------------------------
# [include config/hardware/axis/Y/TMC/TMC2209.cfg]
# [include config/hardware/axis/Y/TMC/TMC2209_V0specific.cfg] # Should only be used for early LDO V0 kits to mitigate the known VFAs issue
# [include config/hardware/axis/Y/TMC/TMC2240.cfg]
# [include config/hardware/axis/Y/TMC/TMC5160.cfg]
### 3. Z Drivers -------------------------------------------------------------------------
# [include config/hardware/axis/Z/TMC/TMC2209_1-Motor.cfg]
# [include config/hardware/axis/Z/TMC/TMC2209_3-Motors.cfg]
# [include config/hardware/axis/Z/TMC/TMC2209_4-Motors.cfg]
# [include config/hardware/axis/Z/TMC/TMC2240_1-Motor.cfg]
# [include config/hardware/axis/Z/TMC/TMC2240_3-Motors.cfg]
# [include config/hardware/axis/Z/TMC/TMC2240_4-Motors.cfg]
# [include config/hardware/axis/Z/TMC/TMC5160_1-Motor.cfg]
# [include config/hardware/axis/Z/TMC/TMC5160_3-Motors.cfg]
# [include config/hardware/axis/Z/TMC/TMC5160_4-Motors.cfg]
# ----------------------------------------------------------------------------------------


# ------------------------------------------------------------------- EXTRUDER DRIVER ----> optional, but only one line need to be selected
### --------------------------------------------------------------------------------------
# [include config/hardware/extruder/TMC/TMC2209.cfg]
# [include config/hardware/extruder/TMC/TMC2240.cfg]
# ----------------------------------------------------------------------------------------

#MCU #0: /dev/serial/by-id/usb-Beacon_Beacon_RevH_98B0F0CC5157355957202020FF120824-if00
#MCU #1: /dev/serial/by-id/usb-Klipper_rp2040_4E363334320E45BA-if00
#MCU #2: /dev/serial/by-id/usb-Klipper_stm32f446xx_330057001551303432323631-if00


## config/mcu_definitions/main/BTT_Octopus_Pro_v1.1.cfg
[board_pins mcu_manufacturer]
aliases:
    MCU_MOTOR0_STEP=PF13   , MCU_MOTOR0_DIR=PF12   , MCU_MOTOR0_ENABLE=PF14   , MCU_MOTOR0_UART=PC4    ,
    MCU_MOTOR1_STEP=PG0    , MCU_MOTOR1_DIR=PG1    , MCU_MOTOR1_ENABLE=PF15   , MCU_MOTOR1_UART=PD11   ,
    MCU_MOTOR2_1_STEP=PF11 , MCU_MOTOR2_1_DIR=PG3  , MCU_MOTOR2_1_ENABLE=PG5  , MCU_MOTOR2_1_UART=PC6  ,
    MCU_MOTOR3_STEP=PG4    , MCU_MOTOR3_DIR=PC1    , MCU_MOTOR3_ENABLE=PA2    , MCU_MOTOR3_UART=PC7    ,
    MCU_MOTOR4_STEP=PF9    , MCU_MOTOR4_DIR=PF10   , MCU_MOTOR4_ENABLE=PG2    , MCU_MOTOR4_UART=PF2    ,
    MCU_MOTOR5_STEP=PC13   , MCU_MOTOR5_DIR=PF0    , MCU_MOTOR5_ENABLE=PF1    , MCU_MOTOR5_UART=PE4    ,
    MCU_MOTOR6_STEP=PE2    , MCU_MOTOR6_DIR=PE3    , MCU_MOTOR6_ENABLE=PD4    , MCU_MOTOR6_UART=PE1    ,
    MCU_MOTOR7_STEP=PE6    , MCU_MOTOR7_DIR=PA14   , MCU_MOTOR7_ENABLE=PE0    , MCU_MOTOR7_UART=PD3    ,

    MCU_STOP0=PG6  , MCU_STOP1=PG9  , MCU_STOP2=PG10 , MCU_STOP3=PG11 ,
    MCU_STOP4=PG12 , MCU_STOP5=PG13 , MCU_STOP6=PG14 , MCU_STOP7=PG15 ,
    MCU_PROBE=PB7  ,
    MCU_SERVOS=PB6 ,

    MCU_HE0=PA0 , MCU_HE1=PA3 , MCU_HE2=PB0 , MCU_HE3=PB11 ,

    MCU_BED0=PA1 ,

    MCU_TB=PF3 ,
    MCU_T0=PF4 , MCU_T1=PF5 , MCU_T2=PF6 , MCU_T3=PF7 ,

    MCU_FAN0=PA8 , MCU_FAN1=PE5 , MCU_FAN2=PD12 , MCU_FAN3=PD13 , MCU_FAN4=PD14 , MCU_FAN5=PD15 ,

    MCU_NEOPIXEL=PB10  ,
    MCU_PS_ON=PE11    ,
    MCU_POWER_DET=PC0 ,

    # EXP1 header
    EXP1_1=PE8   , EXP1_2=PE7   ,
    EXP1_3=PE9   , EXP1_4=PE10  ,
    EXP1_5=PE12  , EXP1_6=PE13  ,  # Slot in the socket on this side
    EXP1_7=PE14  , EXP1_8=PE15  ,
    EXP1_9=<GND> , EXP1_10=<5V> ,

    # EXP2 header
    EXP2_1=PA6   , EXP2_2=PA5   ,
    EXP2_3=PB1   , EXP2_4=PA4   ,
    EXP2_5=PB2   , EXP2_6=PA7   ,  # Slot in the socket on this side
    EXP2_7=PC15  , EXP2_8=<RST> ,
    EXP2_9=<GND> , EXP2_10=<5V> ,


## config/mcu_definitions/toolhead/LDO_Nitehawk-SB_v1.0.cfg
[board_pins toolhead_manufacturer]
mcu: toolhead
aliases:
    MCU_EMOT_EN=gpio25 , MCU_EMOT_STEP=gpio23 , MCU_EMOT_DIR=gpio24 , MCU_EMOT_UART=gpio0 , MCU_EMOT_TX=gpio1 ,

    MCU_ENDSTOP_X=gpio13 , MCU_ENDSTOP_Y=gpio12 ,
    MCU_HV_ENDSTOP=gpio10 ,

    MCU_FAN0=gpio5 , MCU_FAN1=gpio6 , 
    MCU_PWM0=gpio16 , MCU_PWM1=gpio17 ,

    MCU_TEMP=gpio29 , 

    MCU_HEAT=gpio9 , MCU_HEAT_CHAMBER=gpio28 , MCU_NH_TEMP=gpio26 ,

    MCU_RGB=gpio7 , MCU_ACTIVITY_LED=gpio8 ,

    MCU_ADXL_CS=gpio21 , MCU_ADXL_SCK=gpio18 , MCU_ADXL_MOSI=gpio20 , MCU_ADXL_MISO=gpio19 ,

    MCU_FS=gpio3 , MCU_SU=gpio2 , MCU_ST_UART_TX=gpio1 , MCU_ST_UART_RX=gpio0 ,


## user_templates/overrides.cfg
############################################# \
######## USER CONFIG OVERRIDES FILE #########  + --> This will help you personalize my config to your printer :)
############################################# /

# This file is yours! Feel free to edit it in order to include all the needed
# things to adapt my generic config to your machine. This file will not be erased
# when updating the config using moonraker and it will be kept as you've set it.
# You can change every section of the config. You can also add some new custom macros, etc...
# The corresponding documentation can be found in: docs > overrides.md

### Also, keep in mind: if you use a multi-MCU config such as the old school double SKRs or a CANbus toolhead
### board, you will need to specify which components are connected to which board in your own mcu.cfg file!
### Example: if something is connected to the toolhead MCU, you should use "config_pin: toolhead:PIN_NAME".

#> Main control MCUs are called "mcu" (and "secondary" when using a double MCU configuration)
#> Toolhead CANboard MCUs are called "toolhead"
#> MMU/ERCF MCUs are called "mmu" 

# ------------------------------------------------------------------------------------------


#-------------------------#
#   START_PRINT SEQUENCE  #
#-------------------------#

## The START_PRINT sequence is modular and fully customizable. A default START_PRINT sequence is auto-populated based on
## your probe choice (TAP, Dockable, Inductive), but if for some reasons you still want to modify it, please uncomment the following 3
## lines to define a new `variable_startprint_actions`. You can use any number of action or even duplicate some actions if needed.
## Available actions: "bed_soak", "extruder_preheating", "chamber_soak", "extruder_heating", "tilt_calib", "z_offset", "bedmesh", "purge", "clean", "primeline"
##
# [gcode_macro _USER_VARIABLES]
# variable_startprint_actions: "action1", "action2", ...
# gcode: # do not remove this line


#-------------------------#
#   EXTRUDER/BED PIDs     #
#-------------------------#

## Here is an example of some overrides for the PIDs. I put them here as almost everyone will use them,
## so just uncomment the following lines and change the values according to your own machine
# [extruder]
# control: pid
# pid_kp: 26.015
# pid_ki: 1.770
# pid_kd: 95.603

# [heater_bed]
# control: pid
# pid_kp: 38.771
# pid_ki: 1.746
# pid_kd: 215.177


#-------------------------#
#   Z MOTORS DIRECTION    #
#-------------------------#

## Here is an example of some overrides for the motor directions as it's a pretty common one. If you need
## to invert the Z1 or Z3 motor direction on your machine, just uncomment the following lines.
# [stepper_z1]
# dir_pin: !Z1_DIR

# [stepper_z3]
# dir_pin: !Z3_DIR


#-------------------------#
#   Probe Offsets         #
#-------------------------#

## Here is an example of some overrides for bed probes. These frequently have calibrated offsets for xyz,
## and many will need them during setup. If you need to set these, just uncomment the following lines.
# [probe]
# x_offset: -1.85
# y_offset: 29.3
# z_offset: 12.6


